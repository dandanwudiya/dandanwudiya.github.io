{"posts":[{"title":"LeetCode328场周赛","text":"#[LeetCode-周赛]328今天本来打算开始重新写博客的，结果不小心把以前的搞没了，不过学校的电脑上有备份，应该问题不大，话不多说，开始正题： rank: 706/4776 solved: 3/4 比赛链接 1.数组元素和与数字和的绝对差1.1 思路：签到题，简单模拟1.2 code:12345678910111213141516171819class Solution {public: int check(int x){ int res = 0; while(x){ res += x %10; x /= 10; } return res; } int differenceOfSum(vector&lt;int&gt;&amp; nums) { int a = 0, b= 0; for(auto x : nums){ a += x; b += check(x); } return abs(a - b); }}; 2 子矩阵元素加12.1 思路：差分，前缀和第一反应就是模板题，简单的差分应用，差分一般用在频繁对区间进行段落性加减操作，流程就是对区间两端点进行加减操作然后求前缀和恢复数组。 2.2 code:涉及到边界问题所以差分矩阵多开了二，后续再优化 123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; rangeAddQueries(int n, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;vector&lt;int&gt;&gt; res(n + 2, vector&lt;int&gt; (n + 2, 0)); for(auto arr : queries){ int a = arr[0], b = arr[1], c = arr[2], d = arr[3]; res[a][b]++; res[a][d + 1]--; res[c + 1][b]--; res[c + 1][d + 1]++; } for(int i = 0; i &lt;= n + 1; i++){ for(int j = 0; j &lt;= n + 1; j++){ if(!i &amp;&amp; !j) continue; else if(!i) res[i][j] = res[i][j - 1] + res[i][j]; else if(!j) res[i][j] += res[i - 1][j]; else{ res[i][j] += res[i - 1][j] + res[i][j - 1] - res[i - 1][j - 1]; } } } vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt; (n)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) ans[i][j] = res[i][j]; return ans; }}; 2.3复杂度分析：矩阵边长为n，插入次数为m求前缀和的复杂度为 $n^{2}$, 插入的复杂度为m。时间复杂度： o(max($n^{2}$, m))。空间复杂度： o($n^{2}$); 3.统计好子数组的数目3.1 思路： 双指针假设区间[i, j]满足要求, 对于任意的0 ~ i 之间的左端点k ，[k, j]肯定是满足题意的，因此问题可以转化为对于每个右端点j，求满足条件的最靠右的满足条件的左端点i。反证法很容易得到，j向右移动式，i只有可能向左移动。满足单调性，可以用双指针算法。 3.3 code: 题解的i和j跟代码的是反的12345678910111213141516171819202122232425262728293031323334using LL = long long;class Solution {public: LL num(int x){ if(x &lt;= 1) return 0; LL res = (LL) x * (x - 1) / 2; return res; } long long countGood(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; cnt; //哈希表存区间内点的数量 int i = 0, j = 0; LL res = 0; LL ans = 0; while(i &lt; n){ int count = cnt[nums[i]]; res += count; cnt[nums[i]]++; while(res &gt;= k){ //i满足右移的初步条件 LL val = num(cnt[nums[j]]) - num(cnt[nums[j]] - 1); if(res - val &lt; k) break; //向右移就不满足条件了，break掉 res -= val; cnt[nums[j++]]--; } if(res &gt;= k){ //cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; ans += j + 1; } i++; } return ans; }}; 3.3复杂度分析：双指针复杂度是线性的。时间：o(n)空间：o(1) 4.最大价值和与最小价值和的差值4.2思路：所有结点的价值都是正数1.可以枚举所有点root作为路径的端点2.对于一条路径来说，价值和最大的一定是路径的长度，最小的一定是root（因为root是起点，价值大于0）3.由2得路径越长开销越小，因此最长路径一定遍历到了root。综上可以用树型dp来做，树形dp有个经典应用就是求树的最长路径。最大路径和是一个经典树形 DP 问题，类似「树的直径」。由于我们需要去掉一个叶子，那么可以让子树返回两个值： 带叶子的最大路径和； 不带叶子的最大路径和。 对于当前节点，它有多颗子树，我们一颗颗 DFS，假设当前 DFS 完了其中一颗子树，它返回了「当前带叶子的路径和」和「当前不带叶子的路径和」，那么答案有两种情况： 前面最大带叶子的路径和 + 当前不带叶子的路径和； 前面最大不带叶子的路径和 + 当前带叶子的路径和； 然后更新「最大带叶子的路径和」和「最大不带叶子的路径和」。最后返回「最大带叶子的路径和」和「最大不带叶子的路径和」，用来供父节点计算。 4.3 code:1234567891011121314151617181920212223242526272829303132class Solution {public: using PII = pair&lt;long, long&gt; ; vector&lt;vector&lt;int&gt;&gt; g; vector&lt;int&gt; price; long ans = 0; // 返回带叶子的最大路径和，不带叶子的最大路径和 PII dfs(int x, int fa){ long p = price[x], max_s1 = p, max_s2 = 0; for (int y : g[x]) if (y != fa) { auto[s1, s2] = dfs(y, x); // 前面最大带叶子的路径和 + 当前不带叶子的路径和 // 前面最大不带叶子的路径和 + 当前带叶子的路径和 ans = max(ans, max(max_s1 + s2, max_s2 + s1)); max_s1 = max(max_s1, s1 + p); max_s2 = max(max_s2, s2 + p); } return {max_s1, max_s2}; } long long maxOutput(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges, vector&lt;int&gt; &amp;price) { g.resize(n); this -&gt; price = price; for (auto &amp;e : edges) { int x = e[0], y = e[1]; g[x].push_back(y); g[y].push_back(x); // 建树 } dfs(0, -1); return ans; }}; 4.4 复杂度分析：时间复杂度：o(n) 每个点最多被遍历一次空间复杂度：o(n) 递归深度是n，建图需要的额外空间是2 * n","link":"/2023/01/15/LeetCode328%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"cpp可调用对象和function的简单总结","text":"c++可调用对象和function模板类最近在看别的大佬写的题解是看到function想到自己很就没用这个了，都快忘记了，特写一篇文章来总结一些。 c++可调用对象：1.函数指针 c时代的产物，设计的初衷是想要把函数当作变量来处理。抽离出参数类型和返回值后便可以确认函数类型，并用指针来表示。我目前见到的最多的应用就是在写webserver时，系统调用的参数经常用函数指针做回调。 形式：类型说明符 (*函数名) (参数)12int (*fun)(int x) //函数指针的定义int (*fun)(int x，int y) //函数指针的定义 函数指针的赋值函数指针和其他指针一样定义之后使用之前也是需要初始化。函数指针有两个用途：调用函数和做函数的参数1234567891011int Function(int x, int y){ return 0;}int main(){ int (*fun)(int x，int y) //函数指针的定义 fun = &amp;Function //函数指针的赋值方式1 fun = Function //函数指针的赋值方式2 x = (*fun)() //函数指针的调用方式1 x = fun() //函数指针的调用方式2 return 0;} 函数赋值的时候取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，并且赋值的时候函数不需要带圆括号；如果是函数调用，还必须包含一个圆括号括起来的参数表。 遇到过的最常见的使用：123//下面两种声明是等价的void Foo(int i, void(*pFoo)(int)); //pFoo作为一个函数的首地址被传入函数Foo，Foo可以用该地址调用对应的函数，这种行为称为“回调”。void Foo(int i, void pFoo(int)); 2.函数对象 如果在类中重载了调用运算符(),那么该类的对象可以称为函数对象。 123456789101112131415161718192021222324// 重载的运算符相当于成员函数class AddNumber{public: //重载调用运算符 int operator() (int firstNum, int secondNum) const { return firstNum + secondNum; } int operator() (int firstNum, int secondNum, intthirdNum) { return firstNum + secondNum + thirdNum; } }; int main(){ //实例化函数对象 AddNumber add; //结果是3 add(1,2); //相当于调用成员函数， //结果是6 add(1,2,3); return 0;} 函数对象和函数指针相比，因为是类所以可以储存和提取状态，而且因为函数对象的实现可以在类内修改和重载，还可以做inline函数调用，所以设计灵活性上优于函数指针。在泛型算法中大量用到了函数对象作为实参。头文件functional中定义了一组算数运算符，关系运算符，逻辑运算符的模板类作为函数对象来调用。比如priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q 可以定义一个小根堆。 3.lambda表达式 lanbda函数可以理解为未命名的内联函数，与一般函数不同lambda可以定义在函数内部。12345[capture list](parameter list) -&gt; return type {functionbody}//参数列表和返回类型可以忽略auto foo = []{return 1;}//调用方式和正常函数相同std::cout &lt;&lt; foo(); 捕获列表1234567891011121314151617181920//若要在lambda中使用其所在区块中的变量，需要先捕获void foo(){ string m_s = &quot;hello&quot;; //值捕获，m_i和m_s是变量拷贝 auto bar = [m_s]{return m_s;}; m_s = &quot;hello world&quot;; //结果是hello,foo里面储存的是捕获时的副本 std::cout &lt;&lt; bar(); //引用捕获，m_i和m_s是变量本身 string m_s = &quot;hello&quot;; auto bar = [&amp;m_s]{return m_s;}; m_s = &quot;hello world&quot;; //结果是hello world std::cout &lt;&lt; bar(); //对作用域内所有变量采用值捕获 auto baz = [=]{return m_s;}; //对作用域内所有变量采用引用捕获 auto baz = [&amp;]{return m_s;};} 4.function function作为模板库中用来对可调用对象包装的包装器，可以统一上述四种可调用对象的外部调用方式，并且与可调用对象自身类型解耦，只依赖于call signature. 包装普通函数和模板函数12345678910111213141516171819int add(int i, int j){ return i + j;}//普通函数function&lt;int(int, int)&gt; f_add = add;f_add(1,1);//函数指针int (*p_add)(int, int) = add;function&lt;int(int, int)&gt; f_add = add;f_add(1,1);template&lt;typename T&gt;T add(T i, T j){ return i + j;}//模板函数function&lt;int&lt;int, int&gt;&gt; f_add = add&lt;int&gt;;f_add(1,1); 包装函数对象1234567891011121314151617181920struct add{ int operator()(int i, int j) { return i + j; }};//非模板函数对象function&lt;int(int, int)&gt; f_add = add();f_add(1,1);template&lt;typename T&gt;struct add{ T operator()(T i, T j) { return i + j; }};function&lt;int(int,int)&gt; f_add = add&lt;int&gt;();f_add(1,1); 包装lambda表达式1234auto add = [](int i, int j){return i+ j;};//lambda表达式function&lt;int(int,int)&gt; f_add = add;f_add(1,1);","link":"/2023/01/16/cpp%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%92%8Cfunction%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/01/18/hello-world/"},{"title":"LeetCode第389场周赛","text":"rank : 956 / 2591 solved : 3/ 4 1.交替数字和1.1 思路：模拟1.2 code：12345678910111213141516class Solution {public: int alternateDigitSum(int n) { string str = to_string(n); int len = str.size(); int k = (len % 2 == 0) ? -1 : 1; int res = 0; while(n){ int x = n % 10; res += x * k; k *= -1; n /= 10; } return res; }}; 1.3 复杂度分析： 时间复杂度：O(logn) 空间复杂度：O(1) 2.根据第 K 场考试的分数排序2.1思路：排序，很多种方法，随手写了一种：2.2 code：1234567891011121314151617class Solution {public: vector&lt;vector&lt;int&gt;&gt; sortTheStudents(vector&lt;vector&lt;int&gt;&gt;&amp; score, int k) { int n = score.size(), m = score[0].size(); vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(2)); for(int i = 0; i &lt; n; i++) res[i][0] = score[i][k], res[i][1] = i; sort(res.begin(), res.end()); reverse(res.begin(), res.end()); vector&lt;vector&lt;int&gt;&gt; ans(n); for(int i = 0; i &lt; n; i++){ int s = res[i][1]; ans[i] = score[s]; } return ans; }}; 2.3 复杂度分析： 时间复杂度：O(n * log(n)) 空间复杂度：O(n * m); 3. 执行逐位运算使字符串相等3.1思路：i和j可以随便取，因此答案两个数的顺序无关， (0, 1)和(1, 0) -&gt; (1, 1) (1, 1) -&gt; (0, 1) 和 (1, 0); (0, 0) -&gt; (0, 0); 我们可以惊奇的发现只要原字符串中有1， 目标字符串除了全为0之外都可以转化。如果原字符串是全0的，该字符串就无法改变。根据以上连个结论，可以统计一下s 和 target中的 1的数量 a 和 b。 当 a &amp;&amp; b == 0时，仅当 s == target 时可以相互转化。 其余情况下均可以相互转化。 12345678910111213141516class Solution {public: bool makeStringsEqual(string s, string target) { int a = 0, b = 0; for(auto c : s){ if(c == '1') a++; } for(auto c : target){ if(c == '1') b++; } if(a == 0 || b == 0){ return s == target; } return true; }}; 3.3 复杂度分析： 时间复杂度：O(n); 空间复杂度：O(1); 4.拆分数组的最小代价4.1思路：动态规划、区间dp 状态表示： 集合：f[i]表示 1 - i 个数拆分的价值。 属性：价值的最小值。 状态计算：可以按照最后一次拆分数组的位置进行划分： f(i)= min (f(j)+trimmed(nums[j..i - 1]))+k因为需要计算j - i中一个数的个数，因此从后向前扫面比较方便。 123456789101112131415161718192021222324class Solution {public: int minCost(vector&lt;int&gt;&amp; nums, int K) { int n = nums.size(); long long f[n + 1]; memset(f, 0x3f, sizeof f); f[0] = 0; int cnt[n]; for (int i = 1; i &lt;= n; i++) { memset(cnt, 0, sizeof(cnt)); int t = 0; for (int j = i - 1; j &gt;= 0; j--) { // 计算 trimmed 的值 int x = ++cnt[nums[j]]; // 出现次数超过一次才对 trimmed 有贡献 if (x == 2) t += 2; else if (x &gt; 2) t++; // 套用 dp 方程 f[i] = min(f[i], f[j] + t + K); } } return f[n]; }}; 4.3复杂度分析：时间复杂度：O(n * n)空间复杂度：O(n)","link":"/2023/01/22/LeetCode%E7%AC%AC389%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"LeetCode第332场周赛","text":"Rank : 774/ 4547 Solved : 3/4 比赛链接 1.找出数组的串联值1.1 思路：双指针模拟 1234567891011121314151617class Solution {public: long long findTheArrayConcVal(vector&lt;int&gt;&amp; nums) { long long res = 0; int i = 0, j = nums.size() - 1; while(i &lt; j){ string a = to_string(nums[i]); string b = to_string(nums[j]); string str = a + b; int s = stoi(str); res += s; i++, j--; } if(i == j) res += nums[i]; return res; }}; 1.3复杂度分析 时间复杂度：o(n) 空间复杂度：o(1) 2.统计公平数对的数目2.1 思路：数据范围一百万，考虑排序后二分先排序，枚举数对的left，找到右端点满足条件的区间，区间长度就是以当前left满足条件的数对数目，枚举所有的left相加即可。 2.2 code:123456789101112131415class Solution {public: long long countFairPairs(vector&lt;int&gt;&amp; nums, int lower, int upper) { sort(nums.begin(), nums.end()); long long res = 0; for(int i = 0; i &lt; nums.size(); i++){ int a = lower - nums[i]; //区间的 int b = upper - nums[i]; auto it1 = lower_bound(nums.begin() + i + 1, nums.end(), a); //找区间左端点 auto it2 = upper_bound(nums.begin() + i + 1, nums.end(), b);//找区间右端点的下一个点 res += (int)(it2 - it1); } return res; }}; 2.3 复杂度分析： 1.时间复杂度：O(nlog(n)) 排序和二分的复杂度都是*** nlog(n)*** 总的复杂度 nlog(n) 2.空间复杂度：O(nlog(n)) 排序:nlog(n) 额外空间O(1) 3.字符串异或查询3.1思路：针对每次查询，需要先求出满足条件的子串，及求出满足条件的str使得str ^ left == right根据异或的性质对两边同时异或left 得到 str == left ^ right.s的长度是1e4 查询次数是1e5，如果暴力匹配字串过不了，因此考虑预处理s所有整数的二进制表示的字符串长度不会超过30,可以枚举每个字符的后三十位字符所对应的整数存下来，不会超时。 3.2code:1234567891011121314151617181920212223242526class Solution {public: vector&lt;vector&lt;int&gt;&gt; substringXorQueries(string s, vector&lt;vector&lt;int&gt;&gt;&amp; q) { int n = q.size(); vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt; (2, -1)); using PII = pair&lt;int, int&gt;; unordered_map&lt;int, PII&gt; hash; for(int i = 0; i &lt; s.size(); i++){ //预处理 long long k = 0; if(s[i] == '0') { if(!hash.count(0)) hash[0] = {i, i}; continue; } for(int j = i; j &lt; s.size(); j++){ k = k * 2 + s[j] - '0'; if(k &gt; INT_MAX) break; if(hash.count(k) == 0) hash[k] = {i, j}; } } for(int i = 0; i &lt; n; i++){ int t = q[i][0] ^ q[i][1]; if(hash.count(t)) ans[i][0] = hash[t].first, ans[i][1] = hash[t].second; } return ans; }}; 3.3复杂度分析：s.size() == N, queries.size() == M 预处理的复杂度最坏情况下是 N * 30左右，之后查询扫描是O(M) 总的复杂度就是M级别的 时间复杂度：O(M) 空间复杂度：O(M)","link":"/2023/02/12/LeetCode%E7%AC%AC332%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"扔鸡蛋","text":"","link":"/2023/01/23/%E6%89%94%E9%B8%A1%E8%9B%8B/"}],"tags":[{"name":"LC周赛","slug":"LC周赛","link":"/tags/LC%E5%91%A8%E8%B5%9B/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"树形dp","slug":"树形dp","link":"/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"cpp基础","slug":"cpp基础","link":"/tags/cpp%E5%9F%BA%E7%A1%80/"},{"name":"可调用对象","slug":"可调用对象","link":"/tags/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"},{"name":"cpp新特性","slug":"cpp新特性","link":"/tags/cpp%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"区间dp","slug":"区间dp","link":"/tags/%E5%8C%BA%E9%97%B4dp/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"异或","slug":"异或","link":"/tags/%E5%BC%82%E6%88%96/"},{"name":"预处理","slug":"预处理","link":"/tags/%E9%A2%84%E5%A4%84%E7%90%86/"}],"categories":[],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}