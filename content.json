{"posts":[{"title":"LeetCode328场周赛","text":"#[LeetCode-周赛]328今天本来打算开始重新写博客的，结果不小心把以前的搞没了，不过学校的电脑上有备份，应该问题不大，话不多说，开始正题： rank: 706/4776 solved: 3/4 比赛链接 1.数组元素和与数字和的绝对差1.1 思路：签到题，简单模拟1.2 code:12345678910111213141516171819class Solution {public: int check(int x){ int res = 0; while(x){ res += x %10; x /= 10; } return res; } int differenceOfSum(vector&lt;int&gt;&amp; nums) { int a = 0, b= 0; for(auto x : nums){ a += x; b += check(x); } return abs(a - b); }}; 2 子矩阵元素加12.1 思路：差分，前缀和第一反应就是模板题，简单的差分应用，差分一般用在频繁对区间进行段落性加减操作，流程就是对区间两端点进行加减操作然后求前缀和恢复数组。 2.2 code:涉及到边界问题所以差分矩阵多开了二，后续再优化 123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; rangeAddQueries(int n, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;vector&lt;int&gt;&gt; res(n + 2, vector&lt;int&gt; (n + 2, 0)); for(auto arr : queries){ int a = arr[0], b = arr[1], c = arr[2], d = arr[3]; res[a][b]++; res[a][d + 1]--; res[c + 1][b]--; res[c + 1][d + 1]++; } for(int i = 0; i &lt;= n + 1; i++){ for(int j = 0; j &lt;= n + 1; j++){ if(!i &amp;&amp; !j) continue; else if(!i) res[i][j] = res[i][j - 1] + res[i][j]; else if(!j) res[i][j] += res[i - 1][j]; else{ res[i][j] += res[i - 1][j] + res[i][j - 1] - res[i - 1][j - 1]; } } } vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt; (n)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) ans[i][j] = res[i][j]; return ans; }}; 2.3复杂度分析：矩阵边长为n，插入次数为m求前缀和的复杂度为 $n^{2}$, 插入的复杂度为m。时间复杂度： o(max($n^{2}$, m))。空间复杂度： o($n^{2}$); 3.统计好子数组的数目3.1 思路： 双指针假设区间[i, j]满足要求, 对于任意的0 ~ i 之间的左端点k ，[k, j]肯定是满足题意的，因此问题可以转化为对于每个右端点j，求满足条件的最靠右的满足条件的左端点i。反证法很容易得到，j向右移动式，i只有可能向左移动。满足单调性，可以用双指针算法。 3.3 code: 题解的i和j跟代码的是反的12345678910111213141516171819202122232425262728293031323334using LL = long long;class Solution {public: LL num(int x){ if(x &lt;= 1) return 0; LL res = (LL) x * (x - 1) / 2; return res; } long long countGood(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; cnt; //哈希表存区间内点的数量 int i = 0, j = 0; LL res = 0; LL ans = 0; while(i &lt; n){ int count = cnt[nums[i]]; res += count; cnt[nums[i]]++; while(res &gt;= k){ //i满足右移的初步条件 LL val = num(cnt[nums[j]]) - num(cnt[nums[j]] - 1); if(res - val &lt; k) break; //向右移就不满足条件了，break掉 res -= val; cnt[nums[j++]]--; } if(res &gt;= k){ //cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; ans += j + 1; } i++; } return ans; }}; 3.3复杂度分析：双指针复杂度是线性的。时间：o(n)空间：o(1) 4.最大价值和与最小价值和的差值4.2思路：所有结点的价值都是正数1.可以枚举所有点root作为路径的端点2.对于一条路径来说，价值和最大的一定是路径的长度，最小的一定是root（因为root是起点，价值大于0）3.由2得路径越长开销越小，因此最长路径一定遍历到了root。综上可以用树型dp来做，树形dp有个经典应用就是求树的最长路径。最大路径和是一个经典树形 DP 问题，类似「树的直径」。由于我们需要去掉一个叶子，那么可以让子树返回两个值： 带叶子的最大路径和； 不带叶子的最大路径和。 对于当前节点，它有多颗子树，我们一颗颗 DFS，假设当前 DFS 完了其中一颗子树，它返回了「当前带叶子的路径和」和「当前不带叶子的路径和」，那么答案有两种情况： 前面最大带叶子的路径和 + 当前不带叶子的路径和； 前面最大不带叶子的路径和 + 当前带叶子的路径和； 然后更新「最大带叶子的路径和」和「最大不带叶子的路径和」。最后返回「最大带叶子的路径和」和「最大不带叶子的路径和」，用来供父节点计算。 4.3 code:1234567891011121314151617181920212223242526272829303132class Solution {public: using PII = pair&lt;long, long&gt; ; vector&lt;vector&lt;int&gt;&gt; g; vector&lt;int&gt; price; long ans = 0; // 返回带叶子的最大路径和，不带叶子的最大路径和 PII dfs(int x, int fa){ long p = price[x], max_s1 = p, max_s2 = 0; for (int y : g[x]) if (y != fa) { auto[s1, s2] = dfs(y, x); // 前面最大带叶子的路径和 + 当前不带叶子的路径和 // 前面最大不带叶子的路径和 + 当前带叶子的路径和 ans = max(ans, max(max_s1 + s2, max_s2 + s1)); max_s1 = max(max_s1, s1 + p); max_s2 = max(max_s2, s2 + p); } return {max_s1, max_s2}; } long long maxOutput(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges, vector&lt;int&gt; &amp;price) { g.resize(n); this -&gt; price = price; for (auto &amp;e : edges) { int x = e[0], y = e[1]; g[x].push_back(y); g[y].push_back(x); // 建树 } dfs(0, -1); return ans; }}; 4.4 复杂度分析：时间复杂度：o(n) 每个点最多被遍历一次空间复杂度：o(n) 递归深度是n，建图需要的额外空间是2 * n","link":"/2023/01/15/LeetCode328%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"cpp可调用对象和function的简单总结","text":"c++可调用对象和function模板类最近在看别的大佬写的题解是看到function想到自己很就没用这个了，都快忘记了，特写一篇文章来总结一些。 c++可调用对象：1.函数指针 c时代的产物，设计的初衷是想要把函数当作变量来处理。抽离出参数类型和返回值后便可以确认函数类型，并用指针来表示。我目前见到的最多的应用就是在写webserver时，系统调用的参数经常用函数指针做回调。 形式：类型说明符 (*函数名) (参数)12int (*fun)(int x) //函数指针的定义int (*fun)(int x，int y) //函数指针的定义 函数指针的赋值函数指针和其他指针一样定义之后使用之前也是需要初始化。函数指针有两个用途：调用函数和做函数的参数1234567891011int Function(int x, int y){ return 0;}int main(){ int (*fun)(int x，int y) //函数指针的定义 fun = &amp;Function //函数指针的赋值方式1 fun = Function //函数指针的赋值方式2 x = (*fun)() //函数指针的调用方式1 x = fun() //函数指针的调用方式2 return 0;} 函数赋值的时候取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，并且赋值的时候函数不需要带圆括号；如果是函数调用，还必须包含一个圆括号括起来的参数表。 遇到过的最常见的使用：123//下面两种声明是等价的void Foo(int i, void(*pFoo)(int)); //pFoo作为一个函数的首地址被传入函数Foo，Foo可以用该地址调用对应的函数，这种行为称为“回调”。void Foo(int i, void pFoo(int)); 2.函数对象 如果在类中重载了调用运算符(),那么该类的对象可以称为函数对象。 123456789101112131415161718192021222324// 重载的运算符相当于成员函数class AddNumber{public: //重载调用运算符 int operator() (int firstNum, int secondNum) const { return firstNum + secondNum; } int operator() (int firstNum, int secondNum, intthirdNum) { return firstNum + secondNum + thirdNum; } }; int main(){ //实例化函数对象 AddNumber add; //结果是3 add(1,2); //相当于调用成员函数， //结果是6 add(1,2,3); return 0;} 函数对象和函数指针相比，因为是类所以可以储存和提取状态，而且因为函数对象的实现可以在类内修改和重载，还可以做inline函数调用，所以设计灵活性上优于函数指针。在泛型算法中大量用到了函数对象作为实参。头文件functional中定义了一组算数运算符，关系运算符，逻辑运算符的模板类作为函数对象来调用。比如priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q 可以定义一个小根堆。 3.lambda表达式 lanbda函数可以理解为未命名的内联函数，与一般函数不同lambda可以定义在函数内部。12345[capture list](parameter list) -&gt; return type {functionbody}//参数列表和返回类型可以忽略auto foo = []{return 1;}//调用方式和正常函数相同std::cout &lt;&lt; foo(); 捕获列表1234567891011121314151617181920//若要在lambda中使用其所在区块中的变量，需要先捕获void foo(){ string m_s = &quot;hello&quot;; //值捕获，m_i和m_s是变量拷贝 auto bar = [m_s]{return m_s;}; m_s = &quot;hello world&quot;; //结果是hello,foo里面储存的是捕获时的副本 std::cout &lt;&lt; bar(); //引用捕获，m_i和m_s是变量本身 string m_s = &quot;hello&quot;; auto bar = [&amp;m_s]{return m_s;}; m_s = &quot;hello world&quot;; //结果是hello world std::cout &lt;&lt; bar(); //对作用域内所有变量采用值捕获 auto baz = [=]{return m_s;}; //对作用域内所有变量采用引用捕获 auto baz = [&amp;]{return m_s;};} 4.function function作为模板库中用来对可调用对象包装的包装器，可以统一上述四种可调用对象的外部调用方式，并且与可调用对象自身类型解耦，只依赖于call signature. 包装普通函数和模板函数12345678910111213141516171819int add(int i, int j){ return i + j;}//普通函数function&lt;int(int, int)&gt; f_add = add;f_add(1,1);//函数指针int (*p_add)(int, int) = add;function&lt;int(int, int)&gt; f_add = add;f_add(1,1);template&lt;typename T&gt;T add(T i, T j){ return i + j;}//模板函数function&lt;int&lt;int, int&gt;&gt; f_add = add&lt;int&gt;;f_add(1,1); 包装函数对象1234567891011121314151617181920struct add{ int operator()(int i, int j) { return i + j; }};//非模板函数对象function&lt;int(int, int)&gt; f_add = add();f_add(1,1);template&lt;typename T&gt;struct add{ T operator()(T i, T j) { return i + j; }};function&lt;int(int,int)&gt; f_add = add&lt;int&gt;();f_add(1,1); 包装lambda表达式1234auto add = [](int i, int j){return i+ j;};//lambda表达式function&lt;int(int,int)&gt; f_add = add;f_add(1,1);","link":"/2023/01/16/cpp%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%92%8Cfunction%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/01/18/hello-world/"},{"title":"LeetCode第332场周赛","text":"Rank : 774/ 4547 Solved : 3/4 比赛链接 1.找出数组的串联值1.1 思路：双指针模拟 1234567891011121314151617class Solution {public: long long findTheArrayConcVal(vector&lt;int&gt;&amp; nums) { long long res = 0; int i = 0, j = nums.size() - 1; while(i &lt; j){ string a = to_string(nums[i]); string b = to_string(nums[j]); string str = a + b; int s = stoi(str); res += s; i++, j--; } if(i == j) res += nums[i]; return res; }}; 1.3复杂度分析 时间复杂度：o(n) 空间复杂度：o(1) 2.统计公平数对的数目2.1 思路：数据范围一百万，考虑排序后二分先排序，枚举数对的left，找到右端点满足条件的区间，区间长度就是以当前left满足条件的数对数目，枚举所有的left相加即可。 2.2 code:123456789101112131415class Solution {public: long long countFairPairs(vector&lt;int&gt;&amp; nums, int lower, int upper) { sort(nums.begin(), nums.end()); long long res = 0; for(int i = 0; i &lt; nums.size(); i++){ int a = lower - nums[i]; //区间的 int b = upper - nums[i]; auto it1 = lower_bound(nums.begin() + i + 1, nums.end(), a); //找区间左端点 auto it2 = upper_bound(nums.begin() + i + 1, nums.end(), b);//找区间右端点的下一个点 res += (int)(it2 - it1); } return res; }}; 2.3 复杂度分析： 1.时间复杂度：O(nlog(n)) 排序和二分的复杂度都是*** nlog(n)*** 总的复杂度 nlog(n) 2.空间复杂度：O(nlog(n)) 排序:nlog(n) 额外空间O(1) 3.字符串异或查询3.1思路：针对每次查询，需要先求出满足条件的子串，及求出满足条件的str使得str ^ left == right根据异或的性质对两边同时异或left 得到 str == left ^ right.s的长度是1e4 查询次数是1e5，如果暴力匹配字串过不了，因此考虑预处理s所有整数的二进制表示的字符串长度不会超过30,可以枚举每个字符的后三十位字符所对应的整数存下来，不会超时。 3.2code:1234567891011121314151617181920212223242526class Solution {public: vector&lt;vector&lt;int&gt;&gt; substringXorQueries(string s, vector&lt;vector&lt;int&gt;&gt;&amp; q) { int n = q.size(); vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt; (2, -1)); using PII = pair&lt;int, int&gt;; unordered_map&lt;int, PII&gt; hash; for(int i = 0; i &lt; s.size(); i++){ //预处理 long long k = 0; if(s[i] == '0') { if(!hash.count(0)) hash[0] = {i, i}; continue; } for(int j = i; j &lt; s.size(); j++){ k = k * 2 + s[j] - '0'; if(k &gt; INT_MAX) break; if(hash.count(k) == 0) hash[k] = {i, j}; } } for(int i = 0; i &lt; n; i++){ int t = q[i][0] ^ q[i][1]; if(hash.count(t)) ans[i][0] = hash[t].first, ans[i][1] = hash[t].second; } return ans; }}; 3.3复杂度分析：s.size() == N, queries.size() == M 预处理的复杂度最坏情况下是 N * 30左右，之后查询扫描是O(M) 总的复杂度就是M级别的 时间复杂度：O(M) 空间复杂度：O(M)","link":"/2023/02/12/LeetCode%E7%AC%AC332%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"LeetCode第84场双周赛","text":"rank : 1353 / 4574 solved : 3 / 4 1.合并相似的物品1.1 题目描述，给两个二维数组，每个数组里有类别和价值信息， 合并所有同类型的物品。样例： 输入： items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] 输出：[[1,6],[3,9],[4,5]] 限制： 1 &lt;= items1.length, items2.length &lt;= 1000 items1[i].length == items2[i].length == 2 1 &lt;= valuei, weighti &lt;= 1000 items1 中每个 valuei 都是 唯一的 。 items2 中每个 valuei 都是 唯一的 。 1.2 思路： 数据范围很小，暴力枚举可以做， 考虑到代码复杂度，可以开一的哈希表来存储，模拟即可 1.3 code:12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) { unordered_map&lt;int, int&gt; hash; for(auto arr1 : items1){ if(!hash.count(arr1[0])) hash[arr1[0]] = arr1[1]; } for(auto arr2 : items2){ if(!hash.count(arr2[0])) hash[arr2[0]] = arr2[1]; else hash[arr2[0]] += arr2[1]; } vector&lt;vector&lt;int&gt;&gt; res; for(auto [x, v] : hash){ vector&lt;int&gt; arr = {x, v}; res.push_back(arr); } sort(res.begin(), res.end()); return res; }}; 1.4 复杂度分析：时间复杂度：两个数组的总长度，线性的。 空间复杂度：o（n） 2.统计坏数对的数目2.1 题目描述：给你一个下标从 0 开始的整数数组 nums 。如果 i &lt; j 且 j - i != nums[j] - nums[i] ，那么我们称 (i, j) 是一个 坏数对 。 请你返回 nums 中 坏数对 的总数目。 样例： 12345678输入：nums = [4,1,3,3]输出：5解释：数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。总共有 5 个坏数对，所以我们返回 5 。 限制： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^9 2.2思路如果一个数不是坏数对，则 j - i == nums[j] - nums[i]我们可以惊奇的发现： j - nums[j]== i - nums[i], 在数组中记录一下 i - nums[i] 的信息，该值相等的数任意组合都是好数对，因此求出所有的 下标和值的差相等的集合， 对所个集合中的好数对的数量求和，然后再用总的数对减去好数对得到答案。 2.3 code :123456789101112131415161718192021222324252627class Solution {public: typedef long long LL; LL count(int n){ //求解n个数可组成多少个数对。 LL x = (LL)n; x = x * (x - 1); return x / 2; } long long countBadPairs(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for(int i = 0; i &lt; n; i++){ nums[i] = nums[i] - i; } unordered_map&lt;int, int&gt; hash; for(auto x : nums){ if(hash.count(x)) hash[x]++; else hash[x] = 1; } LL res = count(n); LL sub = 0; for(auto [x, v] : hash){ sub += count(v); } res -= sub; return res; }}; 2.4 复杂度分析：时间复杂度：o(n) 最大的就是求解下标和差的过程，因此是线性的。 空间复杂度：o(n) 额外空间就是一个哈希表，最坏的情况就是每个点的值和下标的差都不相同，因此o(n) 3.任务调度器 II3.1 题目描述： 给你一个下标从 0 开始的正整数数组 tasks ，表示需要 按顺序 完成的任务，其中 tasks[i] 表示第 i 件任务的 类型 。 同时给你一个正整数 space ，表示一个任务完成 后 ，另一个 相同 类型任务完成前需要间隔的 最少 天数。 在所有任务完成前的每一天，你都必须进行以下两种操作中的一种： 完成 tasks 中的下一个任务 休息一天 请你返回完成所有任务所需的 最少 天数。 示例 1： 1234567891011121314输入：tasks = [1,2,1,2,3,1], space = 3输出：9解释：9 天完成所有任务的一种方法是：第 1 天：完成任务 0 。第 2 天：完成任务 1 。第 3 天：休息。第 4 天：休息。第 5 天：完成任务 2 。第 6 天：完成任务 3 。第 7 天：休息。第 8 天：完成任务 4 。第 9 天：完成任务 5 。可以证明无法少于 9 天完成所有任务。 3.2 思路；执行过程是有序的，因此模拟整个过程即可， 用day来记录当前的实在第几天，开一个哈希表来记录之前已经执行过的任务的最晚天数，如果放前天需要执行任务x,结果发现距离上一次执行该任务的时间间隔还不到space，更新day = hash[x] + space即可，其他情况不需要等待day++即可。最终的答案就是day。 3.3 code:123456789101112131415161718192021class Solution {public: long long taskSchedulerII(vector&lt;int&gt;&amp; tasks, int space) { typedef long long LL; unordered_map&lt;LL, LL&gt; hash; int n = tasks.size(); LL day = 0; for(int i = 0; i &lt; n; i++){ day++; if(!hash.count(tasks[i]) || day - hash[tasks[i]] &gt; space){ hash[tasks[i]] = day; } else{ day = hash[tasks[i]] + space + 1; hash[tasks[i]] = day; } // cout &lt;&lt; day &lt;&lt; endl; } return day; }}; 3.4 复杂度分析：时间复杂度： o(n)扫描 空间复杂度： o(n) 额外空间只有一个哈希表，最坏复杂度为所有的任务种类均不同。 4.将数组排序的最少替换次数4.1 题目描述：给你一个下表从 0 开始的整数数组 nums 。每次操作中，你可以将数组中任何一个元素替换为 任意两个 和为该元素的数字。 比方说，nums = [5,6,7] 。一次操作中，我们可以将 nums[1] 替换成 2 和 4 ，将 nums 转变成 [5,2,4,7] 。 请你执行上述操作，将数组变成元素按 非递减 顺序排列的数组，并返回所需的最少操作次数。 样例： 1234567输入：nums = [3,9,3]输出：2解释：以下是将数组变成非递减顺序的步骤：- [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3]- [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] 总共需要 2 步将数组变成非递减有序，所以我们返回 2 。 限制： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 109 4.2 思路贪心问题， 可以先把问题转化为将数组分解成从后往前看非递减顺序排列的数组。从后往前枚举整个数组，如果遇到递增序列，需要分解。 假设一个数分解成k个数可以满足条件，那么这个k必然是越小越好，同时分解的几个元素中最前面的数越大越好，因为如果最前面的数越大，之后遍历过程中需要分解的概率就越低。 这两个条件是不冲突的，假设k为满足条件的最小值，那么数组中最前面的数就是 nums[i]/k 因此问题可以转化为贪心求最小的k， 可分为两种情况： 假设nums[i] &gt; nums[i + 1] ,令k = nums[i + 1]; nums[i] 可以整除前面的数，那么k = last / nums[i] nums[i] 不能整除last，那么如果分解必然会有余数，因此k就是对除的结果上取整； 最前面的数就是nums[i] / k 4.3 code:1234567891011121314151617class Solution {public: long long minimumReplacement(vector&lt;int&gt;&amp; nums) { int n = nums.size(); long long res = 0; int last = nums[n - 1]; for(int i = n - 2; i &gt;= 0; i--){ if(nums[i] &lt;= last) last = nums[i]; else{ int k = (nums[i] + last - 1) / last; res += k - 1; last = nums[i] / k; } } return res; }}; 4.4 复杂度分析：时间复杂度：o(n) 线性扫描了数组一遍，因此时间复杂度为数组的长度， 空间复杂度：o(1) 常数级别","link":"/2022/08/07/LeetCode%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"LeetCode第305场周赛","text":"Rank : 2572 / 7372 Solved: 3 / 4 [比赛链接]（竞赛 - 力扣 (LeetCode)） 1 使数组中所有元素都等于零1.1思路即是求所有元素中不为零的不重复的元素的个数，开一个set统计即可。 1.2 code12345678910111213141516class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { unordered_set&lt;int&gt; hash; int res = 0; for(auto x : nums){ if(x){ if(!hash.count(x)) { hash.insert(x); res++; } } } return res; }}; 1.3 复杂度分析时间复杂度： o(n) 空降复杂度：o(n) 2 分组中的最大数量2.1 题目描述：给你一个正整数数组 grades ，表示大学中一些学生的成绩。你打算将 所有 学生分为一些 有序 的非空分组，其中分组间的顺序满足以下全部条件： 第 i 个分组中的学生总成绩 小于 第 (i + 1) 个分组中的学生总成绩，对所有组均成立（除了最后一组）。 第 i 个分组中的学生总数 小于 第 (i + 1) 个分组中的学生总数，对所有组均成立（除了最后一组）。返回可以形成的 最大 组数。 样例： 1234567输入: grades = [10,6,12,7,3,5]输出: 3解释：下面是形成 3 个分组的一种可行方法：- 第 1 个分组的学生成绩为 grades = [12] ，总成绩：12 ，学生数：1- 第 2 个分组的学生成绩为 grades = [6,7] ，总成绩：6 + 7 = 13 ，学生数：2- 第 3 个分组的学生成绩为 grades = [10,3,5] ，总成绩：10 + 3 + 5 = 18 ，学生数：3 可以证明无法形成超过 3 个分组。 限制： 1 &lt;= grades.length &lt;= 1e5 1 &lt;= grades[i] &lt;= 1e5 2.2 思路：可以假定整个数组是有序的（其实不需要排序），并且所有元素都大于零，从前往后枚举每个成员，并且每个小组的元素个数必须是递增的，那么所有小组的总成绩也必然是递增的。 因此我们可以推出如果满足条件2 ：第 i 个分组中的学生总数 小于 第 (i + 1) 个分组中的学生总数，对所有组均成立（除了最后一组）。 必然满足条件1：第 i 个分组中的学生总成绩 小于 第 (i + 1) 个分组中的学生总成绩，对所有组均成立（除了最后一组）。 因此只需要计算n个成员， 最多可以分成多少个递增的小组即可，从1开始模拟即可。 2.3 code：1234567891011121314class Solution {public: int maximumGroups(vector&lt;int&gt;&amp; grades) { int res = 0; int n = grades.size(); int k = 1; //k为当前组至少需要多少个成员。 while(n &gt;= k){ //假定剩下的成员至少还可以分一组。 n -= k; k++; //该组的成员数 res++; //组数 } return res; }}; 2.4 复杂度分析： 时间复杂度： o($\\sqrt{n}$) 从一到 k 等差数列求和直到和为n为止。 空间复杂度： o(1) 3 找到离给定两个节点最近的节点3.1 题目描述：给定一个有向图和两个点， 需要求出图中到这两个点的具体的较大值最小的点， 返回该点的编号。 注意: edges 可能包含环。 样例： 12输入：edges = [2,2,3,-1], node1 = 0, node2 = 1输出：2 限制: 12345n == edges.length2 &lt;= n &lt;= 1e5-1 &lt;= edges[i] &lt; nedges[i] != i0 &lt;= node1, node2 &lt; n 3.2 思路：分别计算两个点x和y能遍历到的点的距离， 再从小到大枚举每个点， 如果该点是x和y都能遍历到的点，求出具体的较大值，更新最大值的最小值和点的编号。 可以开一个vector 下标为点的id， 值为距离，将所有值初始化为-1， 如果遍历的过程中发现值被更新过了，说明走到了环的入口，此时再往下走就已经不是最短距离了， break掉即可。 3.3 code:123456789101112131415161718192021222324252627282930313233class Solution {public: int closestMeetingNode(vector&lt;int&gt;&amp; e, int node1, int node2) { int n = e.size(); vector&lt;int&gt; a(n, -1), b(n, -1); int x = node1, y = node2; a[x] = b[y] = 0; while(e[x] != -1){ if(a[e[x]] != -1) break; a[e[x]] = a[x] + 1; // cout &lt;&lt; e[x] &lt;&lt; ' ' &lt;&lt; a[e[x]] &lt;&lt; endl; x = e[x]; } while(e[y] != -1){ if(b[e[y]] != -1) break; b[e[y]] = b[y] + 1; y = e[y]; } int res = -1, id = -1; // res 为两个点的距离较大值， id为距离较大值的最小值的点的编号 for(int i = 0; i &lt; n; i++){ int x = a[i], y = b[i]; if(x != -1 &amp;&amp; y != -1){ if(res == -1 || res &gt; max(x, y)){ res = max(x, y); //更新较大值的最小值 id = i; } } } return id; }}; 3.4 复杂度分析： 时间复杂度：o(n) 点和边的最大值都为n，因此初始化距离和id两个步骤的复杂度都是o（n）。 空间复杂度：o(n). 额为维护了所有点到两个点的距离。o（n） 4. 图中的最长环4.1 题目描述 给定一个有向图，求出图中最长的环的长度， 如果无环返回-1. 样例： 输入：edges = [3,3,4,2,3] 输出：3 限制： 2 &lt;= n &lt;= 105 -1 &lt;= edges[i] &lt; n edges[i] != i 4.2 思路开两个数组， 分别记录每个点被遍历过和每个点在当前层被遍历过。 深度优先遍历：dfs每一个点， 维护一下深度deepth， 并记录一下该点是否被遍历过，如果是被遍历过并且在该层递归函数中被遍历过的，则说明找到了环的入口，更新一下答案。如果当前点没有被遍历过，则递归当前点并且depth++。如果当前点被遍历过但是不是当前层遍历的，则说明该店已经被维护过了， 不用处理即可。 4.3 code:123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: vector&lt;int&gt; p; vector&lt;bool&gt; st; //记录一下该店是否被遍历过。 vector&lt;int&gt; in_stk; //是否在当前层被遍历过。 int ans = -1; void dfs(int u, int depth) { st[u] = true; in_stk[u] = depth; int j = p[u]; if (j != -1) { if !st[j]) { //没有被维护过 dfs(j, depth + 1); } else if (in_stk[j]) { //找到了环的入口， 更新答案。 ans = max(ans, depth + 1 - in_stk[j]); } // else ... 该点已经被维护过了， 不用处理。} } in_stk[u] = 0; } int longestCycle(vector&lt;int&gt;&amp; p) { this-&gt;p = p; int n = p.size(); st = vector&lt;bool&gt;(n); in_stk = vector&lt;int&gt;(n); for (int i = 0; i &lt; n; i ++ ) if (!st[i]) dfs(i, 1); return ans; }}; 4.4 复杂度分析： 时间复杂度： o(n) 总共会遍历n个点， 每个点最多遍历一次。 空间复杂度：o(n) 每个点至多递归一次， 总共至多递归n层。","link":"/2022/07/31/LeetCode%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"LeetCode第305场周赛","text":"rank：1826/7465 solved：3/4 [比赛链接](竞赛 - 力扣 (LeetCode)) 1.算术三元组的数目1.思路数据范围只有200， 暴力枚举三重循环。 1.2 code1234567891011121314class Solution {public: int arithmeticTriplets(vector&lt;int&gt;&amp; nums, int d) { int n = nums.size(); int res = 0; for(int i = 0; i &lt; n; i++){ for(int j = i + 1; j &lt; n; j++) for(int k = j + 1; k &lt; n; k++){ if(nums[j] - nums[i] == d &amp;&amp; nums[k] - nums[j] == d) res ++; } } return res; }}; 1.3 复杂度分析时间复杂度：o(n^3) 空间复杂度：o(1) 2.受限条件下可到达节点的数目2.1 题目描述：给定一颗无向树， 还有一些受限制的点，受限制的点无法遍历，求解根节点0能到的点的数目。 样例 输入： n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5] 输出： 4 2.2思路题目给的是变，先根据边的信息建图，因为树本来就是稀疏图，因此选择邻接表来存储图 然后dfs遍历，开一个bool型的数组记录已经被遍历过的数， 开一个set来存储受限制的点，每次递归ans都要++。由于力扣的评测规则全局变量每次都需要重新初始化。 2.3 code：123456789101112131415161718192021222324252627282930313233343536373839404142const int N = 100010, M = 2 * N;int h[N], e[M], ne[M], idx;bool st[N];unordered_set&lt;int&gt; res;int ans = 0;class Solution {public: void add(int a, int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx++; } void dfs(int u){ // cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt;st[u] &lt;&lt; endl; st[u] = true; ans++; for(int i = h[u]; i != -1; i = ne[i]){ int j = e[i]; if(!st[j] &amp;&amp; !res.count(j)) dfs(j); } } int reachableNodes(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; restricted) { memset(h, -1, sizeof(h)); idx = 0; memset(e, 0, sizeof e); memset(ne, 0, sizeof ne); memset(st, 0, sizeof st); ans = 0; res.clear(); for(auto arr : edges){ int a = arr[0], b = arr[1]; add(a, b), add(b, a); } for(auto x : restricted) res.insert(x); dfs(0); return ans; }}; 2.4 复杂度分析： 时间复杂度 ：o(n) 空间复杂度： o(M) N 为最大的点的数量，因为是无向图所以边的存储数量要乘以2，递归函数最多有n层，因此最终整体的空间复杂度为o(M); 3.检查数组是否存在有效划分3.1 题目描述：给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个连续子数组。 如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分： 子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。 子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。 子数组 恰 由 3 个连续递增元素组成，并且相邻元素之间的差值为 1 。例如，子数组 [3,4,5] ，但是子数组 [1,3,5] 不符合要求。 如果数组 至少 存在一种有效划分，返回 true ，否则，返回 false 。 输入：nums = [4,4,4,5,6] 输出： true 3.2 思路动态规划的思想，从前向后枚举所有的点，如果0 - k 这个区间是一个有效划分，则末尾二到三个数必然是三种情况之一，因此可以用之前的状态求解现在的状态。 状态表示： f[i] == true 表示前i 个数是一种有效划分， 状态转移： 三种情况满足一种时则可认为是有效划分。 1. nums[i] == nums[i - 1] == nums[i - 2] &amp;&amp; f[i - 3] == true; 2. nums[i] == nums[i - 1] &amp;&amp; f[i - 3] == true; 3. nums[i] - nums[i - 1] == 1 &amp;&amp; nums[i - 1] - nums[i - 1] == 1 &amp;&amp; f[i - 2] == true 3.3 code:123456789101112131415161718class Solution {public: bool validPartition(vector&lt;int&gt;&amp; nums) { const int n = nums.size(); vector&lt;bool&gt; f(n + 1, false); f[0] = true; if(nums[0] == nums[1]) f[2] = true; for(int i = 3; i &lt;= n; i++){ if(nums[i - 1] == nums[i - 2] &amp;&amp; nums[i - 2] == nums[i - 3] &amp;&amp; f[i - 3]) f[i] = true; if(nums[i - 1] - nums[i - 2] == 1 &amp;&amp; nums[i - 2] - nums[i - 3] ==1 &amp;&amp; f[i - 3]) f[i] = true; if(nums[i - 1] == nums[i - 2] &amp;&amp; f[i - 2]) f[i] = true; // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; f[i] &lt;&lt; endl; } return f[n]; }}; 3.4 复杂度分析： 时间复杂度： o(n) 只扫描了一编 空间复杂度： o(n) 开了线性长度的数组 4.最长理想子序列（补题）4.1 题目描述：给定一个串， 求其中的最长的子序列的长度，该子序列必须满足是一个理想串。 理想串的概念： t 中每两个 相邻 字母在字母表中位次的绝对差值小于或等于 k。 样例： 1234输入：s = &quot;acfgbd&quot;, k = 2输出：4解释：最长理想字符串是 &quot;acbd&quot; 。该字符串长度为 4 ，所以返回 4 。注意 &quot;acfgbd&quot; 不是理想字符串，因为 'c' 和 'f' 的字母表位次差值为 3 。 4.2 思路动态规划：开一个长度为26的一维数组f。 状态表示：当前字母用c 表示f[c - 'a'] 表示以c结尾的理想子序列的最大值。 状态转移：对于当前位置 c:=s(i)，找到下标 [c−k,c+k]内的 ff的最大值 m，转移f(c)=m+1。 最终答案为所有f求一个max 4.3 code:123456789101112131415161718192021222324class Solution {public: int longestIdealString(string s, int k) { const int n = s.size(); vector&lt;int&gt; f(26, 0); for (int i = 0; i &lt; n; i++) { int c = s[i] - 'a'; int m = 0; for (int j = max(0, c - k); j &lt;= min(25, c + k); j++) m = max(m, f[j]); f[c] = m + 1; } int ans = 0; for (int i = 0; i &lt; 26; i++) ans = max(ans, f[i]); return ans; }}; 4.4 复杂度分析：时间复杂度： 总共对数组扫了一遍，每个数都用前后k个数更新，总时间复杂度 o(nk) 空间复杂度： 数组大小：常数级别。 总结：前三题做的比较顺利，最后一道题状态表示写成了二维的，然后写转移的时候比较复杂，看了别人的题解豁然开朗，后续刷题的话还是多思考。这次最后一题是个middle难度的题，没做出来有点遗憾。","link":"/2022/08/07/LeetCode%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"LeetCode第306场周赛","text":"rank : 2341/7550 solved: 3 / 4 1.矩阵中的局部最大值1.1题目描述：给你一个大小为 n x n 的整数矩阵 grid 。 生成一个大小为 (n - 2) x (n - 2) 的整数矩阵 maxLocal ，并满足： maxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。 换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。 返回生成的矩阵。 样例： 输入： grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] 输出：[[9,9],[8,6]] 1.2 思路：简单模拟一下。 1.3 code：12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; g; int check(int a, int b){ int ans = 0; for(int i = a; i &lt; a + 3; i++){ for(int j = b; j &lt; b + 3; j++) ans = max(ans, g[i][j]); } return ans; } vector&lt;vector&lt;int&gt;&gt; largestLocal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { g = grid; int n = grid.size(); vector&lt;vector&lt;int&gt;&gt; res(n - 2, vector&lt;int&gt; (n - 2)); int m = n - 2; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; m; j++){ res[i][j] = check(i, j); } } return res; }}; 1.4 复杂度分析：时间复杂度：o(n^2) 空间复杂度：o(n^2) 2.边积分最高的节点2.1 题目描述：给你一个有向图，图中有 n 个节点，节点编号从 0 到 n - 1 ，其中每个节点都 恰有一条 出边。 图由一个下标从 0 开始、长度为 n 的整数数组 edges 表示，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的 有向 边。 节点 i 的 边积分 定义为：所有存在一条指向节点 i 的边的节点的 编号 总和。 返回 边积分 最高的节点。如果多个节点的 边积分 相同，返回编号 最小 的那个。 样例： 输入： edges = [1,0,0,0,0,7,7,5]输出： 7 2.2思路开一个set，存储每个点的积分，从小到大枚举set中的元素，找到得分最大的点。 2.3 code:12345678910111213141516171819class Solution {public: int edgeScore(vector&lt;int&gt;&amp; edges) { int n = edges.size(); map&lt;int, long long&gt; hash; for(int i = 0; i &lt; n; i++){ hash[edges[i]] += i; } long long ans_max = 0; int ans = 0; for(auto [k, v] : hash){ if(v &gt; ans_max){ ans_max = v; ans = k; } } return ans; }}; 2.4 复杂度分析：时间复杂度： o(n*log(n)) map插入的复杂度为log(n) ，总共插入n个数，总的复杂度是n*log(n) 空间复杂度：o(n) 额外开了一个map，最大长度为n。 3.根据模式串构造最小数字3.1 题目描述：给你下标从 0 开始、长度为 n 的字符串 pattern ，它包含两种字符，'I' 表示 上升 ，'D' 表示 下降 。 你需要构造一个下标从 0 开始长度为 n + 1 的字符串，且它要满足以下条件： num 包含数字 '1' 到 '9' ，其中每个数字 至多 使用一次。 如果 pattern[i] == 'I' ，那么 num[i] &lt; num[i + 1] 。 如果 pattern[i] == 'D' ，那么 num[i] &gt; num[i + 1] 。 请你返回满足上述条件字典序 最小 的字符串 num。 样例： 输入： pattern = “IIIDIDDD” 输出：“123549876” 3.2 思路：答案最大长度是9，因此可以考虑用dfs暴搜，对每个位置上的值从小到大枚举，因此第一种合法方案就一定是最优解。 3.3 code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: string p; bool st[10]; int n; string path; string ans; void dfs(int u){ if(u &gt; n){ ans = min(ans, path); return ; } if(!u){ for(char i = '1'; i &lt;= '9'; i++){ if(!st[i - '1']){ path[u] = i; st[i - '1'] = true; dfs(u + 1); st[i - '1'] = false; } } } else{ for(char i = '1'; i &lt;= '9'; i++){ if(p[u - 1] == 'I' &amp;&amp; i &lt;= path[u - 1]) continue; if(p[u - 1] == 'D' &amp;&amp; i &gt;= path[u - 1]) break; if(!st[i - '1']){ path[u] = i; st[i - '1'] = true; dfs(u + 1); st[i - '1'] = false; } } } } string smallestNumber(string pattern) { p = pattern; n = p.size(); ans = string(n + 1, '9'); path = string(n + 1, '9'); dfs(0); return ans; }}; 3.4 复杂度分析：时间复杂度：o(n!) 最差情况下为求出所有的可能的排列，总共有n!种情况 空间复杂度：o(n!) 递归最多开o(n !) 个空间。 4.统计特殊整数4.1 题目描述：如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。 给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。 样例： 123**输入：** n = 20**输出：** 19**解释：** 1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。 4.2 思路：最大数据为2e9，枚举肯定会爆掉，考虑用数位dp的思想来做； 假设n是一个m为数，可以将所有可行的方案分成两种情况， 长度等于m和小于m的。 1.长度小于m： 从最高位开始取，每个数不能重复，因此共有$\\prod_{i = 0}^{m -1}{9 - i}$ 种情况， 2.长度等于m： 用数位dp的思想求所有小于n的合法方案，详见代码里注释： 4.3 code:123456789101112131415161718192021222324252627282930313233343536class Solution {public: int countSpecialNumbers(int n) { vector&lt;int&gt; nums; int x = n; while (x) nums.push_back(x % 10), x /= 10; int res = 0; for (int i = 1; i &lt; nums.size(); i ++ ) { //所有长度小于m的方案总数。 int t = 9; for (int j = 0, k = 9; j &lt; i - 1; j ++, k -- ) { t *= k; } res += t; } reverse(nums.begin(), nums.end()); bool st[10] = {0};//存储每个被用过的数。 for (int i = 0; i &lt; nums.size(); i ++ ) { //从前往后枚举每个位置 for (int j = !i; j &lt; nums[i]; j ++ ) { //每个位置可能有多少种取值，第一个位置不能取0 if (st[j]) continue; //j已经再之前被用过 int t = 1; //当0到i位和n相同时，共有多少种合法方案 for (int k = 1, u = 10 - i - 1; k &lt;= nums.size() - i - 1; k ++, u -- ) t *= u; res += t; } if (st[nums[i]]) break; //如果n当中存在两个完全相同的数，则剩下的一定不是合法方案 st[nums[i]] = true; } set&lt;int&gt; S(nums.begin(), nums.end());//看看n自身是不是一种合法方案 if (nums.size() == S.size()) res ++ ; return res; }}; 4.4 复杂度分析：时间复杂度：o((logn)^3) log是以10为底的，最大复杂度1000. 空间复杂度：o(log(n)) n的最大位数。","link":"/2022/08/14/LeetCode%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"LeetCode第389场周赛","text":"rank : 956 / 2591 solved : 3/ 4 1.交替数字和1.1 思路：模拟1.2 code：12345678910111213141516class Solution {public: int alternateDigitSum(int n) { string str = to_string(n); int len = str.size(); int k = (len % 2 == 0) ? -1 : 1; int res = 0; while(n){ int x = n % 10; res += x * k; k *= -1; n /= 10; } return res; }}; 1.3 复杂度分析： 时间复杂度：O(logn) 空间复杂度：O(1) 2.根据第 K 场考试的分数排序2.1思路：排序，很多种方法，随手写了一种：2.2 code：1234567891011121314151617class Solution {public: vector&lt;vector&lt;int&gt;&gt; sortTheStudents(vector&lt;vector&lt;int&gt;&gt;&amp; score, int k) { int n = score.size(), m = score[0].size(); vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(2)); for(int i = 0; i &lt; n; i++) res[i][0] = score[i][k], res[i][1] = i; sort(res.begin(), res.end()); reverse(res.begin(), res.end()); vector&lt;vector&lt;int&gt;&gt; ans(n); for(int i = 0; i &lt; n; i++){ int s = res[i][1]; ans[i] = score[s]; } return ans; }}; 2.3 复杂度分析： 时间复杂度：O(n * log(n)) 空间复杂度：O(n * m); 3. 执行逐位运算使字符串相等3.1思路：i和j可以随便取，因此答案两个数的顺序无关， (0, 1)和(1, 0) -&gt; (1, 1) (1, 1) -&gt; (0, 1) 和 (1, 0); (0, 0) -&gt; (0, 0); 我们可以惊奇的发现只要原字符串中有1， 目标字符串除了全为0之外都可以转化。如果原字符串是全0的，该字符串就无法改变。根据以上连个结论，可以统计一下s 和 target中的 1的数量 a 和 b。 当 a &amp;&amp; b == 0时，仅当 s == target 时可以相互转化。 其余情况下均可以相互转化。 12345678910111213141516class Solution {public: bool makeStringsEqual(string s, string target) { int a = 0, b = 0; for(auto c : s){ if(c == '1') a++; } for(auto c : target){ if(c == '1') b++; } if(a == 0 || b == 0){ return s == target; } return true; }}; 3.3 复杂度分析： 时间复杂度：O(n); 空间复杂度：O(1); 4.拆分数组的最小代价4.1思路：动态规划、区间dp 状态表示： 集合：f[i]表示 1 - i 个数拆分的价值。 属性：价值的最小值。 状态计算：可以按照最后一次拆分数组的位置进行划分： f(i)= min (f(j)+trimmed(nums[j..i - 1]))+k因为需要计算j - i中一个数的个数，因此从后向前扫面比较方便。 123456789101112131415161718192021222324class Solution {public: int minCost(vector&lt;int&gt;&amp; nums, int K) { int n = nums.size(); long long f[n + 1]; memset(f, 0x3f, sizeof f); f[0] = 0; int cnt[n]; for (int i = 1; i &lt;= n; i++) { memset(cnt, 0, sizeof(cnt)); int t = 0; for (int j = i - 1; j &gt;= 0; j--) { // 计算 trimmed 的值 int x = ++cnt[nums[j]]; // 出现次数超过一次才对 trimmed 有贡献 if (x == 2) t += 2; else if (x &gt; 2) t++; // 套用 dp 方程 f[i] = min(f[i], f[j] + t + K); } } return f[n]; }}; 4.3复杂度分析：时间复杂度：O(n * n)空间复杂度：O(n)","link":"/2023/01/22/LeetCode%E7%AC%AC329%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"cpp内存泄漏","text":"总结了一下c++在使用的过程中容易出现的内存泄露的场景和避免方式 c++语言为了追求高性能，所有的内存分配和释放都交给开发者来做，好处是内存管理的开销较小，程序拥有更高的执行效率；弊端是依赖于开发者的水平，随着代码规模的扩大，极容易遗漏释放内存的步骤，对于一些在服务器上长期运行的软件，若存在内存泄漏则会造成严重后果，例如性能下降、程序终止、系统崩溃、无法提供服务等。 1 c++内存分配区域1.1 栈在栈上静态分配内存时由编译器完成，假如局部变量以及函数参数等，都在编译期就分配好了。 >folded123void fun() { int a[10];} 以上代码中，a占10 * sizeof(int)个字节，在编译的时候直接计算好了，运行的时候，直接进栈出栈。不存在 1.2 堆堆（heap）是一种内存管理方式。内存管理对操作系统来说是一件非常复杂的事情，因为首先内存容量很大，其次就是内存需求在时间和大小块上没有规律（操作系统上运行着几十甚至几百个进程，这些进程可能随时都会申请或者是释放内存，并且申请和释放的内存块大小是随意的）。 c++在堆上只支持动态的开辟内存 c++程序运行中，如果在堆上开辟内存，需要调用malloc() 函数，释放则free() 函数 特点： 变量可以在进程范围内访问，即进程内的所有线程都可以访问该变量 没有内存大小限制，这个其实是相对的，只是相对于栈大小来说没有限制，其实最终还是受限于RAM 相对栈来说访问比较慢 内存碎片 由开发者管理内存，即内存的申请和释放都由开发人员来操作 因为堆上的内存空间由开发者动态申请和释放这一特点，如果没有及时释放很容易造成内存泄露。 2.分类2.1 未释放在c/c++中都比较常见的一种情况： >folded123456int fun() { char * pBuffer = malloc(sizeof(char)); /* Do some work */ return 0;} 上面代码是非常常见的内存泄漏场景(也可以使用new来进行分配)，我们申请了一块内存，但是在fun函数结束时候没有调用free函数进行内存释放。在c++中还有一种比较常见的情况： >folded123456789101112131415class Obj { public: Obj(int size) { buffer_ = new char; } ~Obj(){} private: char *buffer_;};int fun() { Object obj; // do sth return 0;} 以上代码中构造函数new了一片空间，但是析构函数没有delete释放，整个程序运行的过程中操作系统都无法对这块内存回收，造成内存泄漏。所以在编写析构函数的时候，一定要仔细分析成员变量有没有申请动态内存，如果有，则需要手动释放，我们重新编写了析构函数，如下： >folded123~Object() { delete buffer_;} 在C/C++中，对于普通函数，如果申请了堆资源，请跟进代码的具体场景调用free/delete进行资源释放；对于class，如果申请了堆资源，则需要在对应的析构函数中调用free/delete进行资源释放。 2.2 未匹配 在内存分配和使用的过程中，new 和 delete对应， malloc 和free对应，new [] 和 delete [] 对应。错误样例如下： new和free混用>folded12Test *t = new Test;free(t) 此处会产生内存泄漏，在上面，我们已经分析过，new操作符会先通过operator new分配一块内存，然后在该块内存上调用placement new即调用Test的构造函数。而在上述代码中，只是通过free函数释放了内存，但是没有调用Test的析构函数以释放Test的成员变量，从而引起内存泄漏。 new [] 和 delete混用：>folded1234567891011121314151617class Test { public: Test() { std::cout &lt;&lt; &quot;in Test&quot; &lt;&lt; std::endl; } // other ~Test() { std::cout &lt;&lt; &quot;in ~Test&quot; &lt;&lt; std::endl; }};int main() { Test *t = new Test [10]; // do sth delete t; return 0;} 程序输出结果入下：1234567891011in Testin Testin Testin Testin Testin Testin Testin Testin Testin Testin ~Test 从上面输出结果可以看出，调用了10次构造函数，但是只调用了一次析构函数，所以引起了内存泄漏。这是因为调用delete t释放了通过operator new[] 申请的内存，即malloc申请的内存块，且只调用了t[0]对象的析构函数，t[1..9]对象的析构函数并没有被调用。 3.避免方式：3.1 避免在堆上分配众所周知，大部分的内存泄漏都是因为在堆上分配引起的，如果我们不在堆上进行分配，就不会存在内存泄漏了(这不废话嘛)，我们可以根据具体的使用场景，如果对象可以在栈上进行分配，就在栈上进行分配，一方面栈的效率远高于堆，另一方面，还能避免内存泄漏，我们何乐而不为呢。 3.2 手动释放 对于malloc函数分配的内存，在结束使用的时候，使用free函数进行释放 对于new操作符创建的对象，切记使用delete来进行释放 对于new []创建的对象，使用delete[]来进行释放(使用free或者delete均会造成内存泄漏) 3.3尽量避免裸指针的使用 除非因为一些历史遗留原因导致某些接口中还是使用指针作为参数，否则尽量不要使用 3.4智能指针自C++11开始，STL中引入了智能指针(smart pointer)来动态管理资源，针对使用场景的不同，提供了以下三种智能指针。 shared_ptr 共享管理权即多个shared_ptr可以共用同一块关联对象，其内部采用的是引用计数，在拷贝的时候，引用计数+1，而在某个对象退出作用域或者释放的时候，引用计数-1，当引用计数为0的时候，会自动释放其管理的对象。 unique_ptrunique_ptr是限制最严格的一种智能指针，用来替代之前的auto_ptr，独享被管理对象指针所有权。当unique_ptr对象被销毁时，会在其析构函数内删除关联的原始指针。 weak_ptr 用来解决shared_ptr导致的环形引用问题，其主要是与shared_ptr一起来私用。和shared_ptr不同的地方在于，其并不会拥有资源，不会修改shared_ptr的引用计数。","link":"/2023/02/13/cpp%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"}],"tags":[{"name":"LC周赛","slug":"LC周赛","link":"/tags/LC%E5%91%A8%E8%B5%9B/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"树形dp","slug":"树形dp","link":"/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"cpp基础","slug":"cpp基础","link":"/tags/cpp%E5%9F%BA%E7%A1%80/"},{"name":"可调用对象","slug":"可调用对象","link":"/tags/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"},{"name":"cpp新特性","slug":"cpp新特性","link":"/tags/cpp%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"区间dp","slug":"区间dp","link":"/tags/%E5%8C%BA%E9%97%B4dp/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"异或","slug":"异或","link":"/tags/%E5%BC%82%E6%88%96/"},{"name":"预处理","slug":"预处理","link":"/tags/%E9%A2%84%E5%A4%84%E7%90%86/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"力扣周赛","slug":"力扣周赛","link":"/tags/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位dp","slug":"数位dp","link":"/tags/%E6%95%B0%E4%BD%8Ddp/"},{"name":"内存泄漏","slug":"内存泄漏","link":"/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"智能指针","slug":"智能指针","link":"/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"}],"categories":[],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}