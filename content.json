{"posts":[{"title":"LeetCode328场周赛","text":"#[LeetCode-周赛]328今天本来打算开始重新写博客的，结果不小心把以前的搞没了，不过学校的电脑上有备份，应该问题不大，话不多说，开始正题： rank: 706/4776 solved: 3/4 比赛链接 1.数组元素和与数字和的绝对差1.1 思路：签到题，简单模拟1.2 code:12345678910111213141516171819class Solution {public: int check(int x){ int res = 0; while(x){ res += x %10; x /= 10; } return res; } int differenceOfSum(vector&lt;int&gt;&amp; nums) { int a = 0, b= 0; for(auto x : nums){ a += x; b += check(x); } return abs(a - b); }}; 2 子矩阵元素加12.1 思路：差分，前缀和第一反应就是模板题，简单的差分应用，差分一般用在频繁对区间进行段落性加减操作，流程就是对区间两端点进行加减操作然后求前缀和恢复数组。 2.2 code:涉及到边界问题所以差分矩阵多开了二，后续再优化 123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; rangeAddQueries(int n, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;vector&lt;int&gt;&gt; res(n + 2, vector&lt;int&gt; (n + 2, 0)); for(auto arr : queries){ int a = arr[0], b = arr[1], c = arr[2], d = arr[3]; res[a][b]++; res[a][d + 1]--; res[c + 1][b]--; res[c + 1][d + 1]++; } for(int i = 0; i &lt;= n + 1; i++){ for(int j = 0; j &lt;= n + 1; j++){ if(!i &amp;&amp; !j) continue; else if(!i) res[i][j] = res[i][j - 1] + res[i][j]; else if(!j) res[i][j] += res[i - 1][j]; else{ res[i][j] += res[i - 1][j] + res[i][j - 1] - res[i - 1][j - 1]; } } } vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt; (n)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) ans[i][j] = res[i][j]; return ans; }}; 2.3复杂度分析：矩阵边长为n，插入次数为m求前缀和的复杂度为 $n^{2}$, 插入的复杂度为m。时间复杂度： o(max($n^{2}$, m))。空间复杂度： o($n^{2}$); 3.统计好子数组的数目3.1 思路： 双指针假设区间[i, j]满足要求, 对于任意的0 ~ i 之间的左端点k ，[k, j]肯定是满足题意的，因此问题可以转化为对于每个右端点j，求满足条件的最靠右的满足条件的左端点i。反证法很容易得到，j向右移动式，i只有可能向左移动。满足单调性，可以用双指针算法。 3.3 code: 题解的i和j跟代码的是反的12345678910111213141516171819202122232425262728293031323334using LL = long long;class Solution {public: LL num(int x){ if(x &lt;= 1) return 0; LL res = (LL) x * (x - 1) / 2; return res; } long long countGood(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; cnt; //哈希表存区间内点的数量 int i = 0, j = 0; LL res = 0; LL ans = 0; while(i &lt; n){ int count = cnt[nums[i]]; res += count; cnt[nums[i]]++; while(res &gt;= k){ //i满足右移的初步条件 LL val = num(cnt[nums[j]]) - num(cnt[nums[j]] - 1); if(res - val &lt; k) break; //向右移就不满足条件了，break掉 res -= val; cnt[nums[j++]]--; } if(res &gt;= k){ //cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; ans += j + 1; } i++; } return ans; }}; 3.3复杂度分析：双指针复杂度是线性的。时间：o(n)空间：o(1) 4.最大价值和与最小价值和的差值4.2思路：所有结点的价值都是正数1.可以枚举所有点root作为路径的端点2.对于一条路径来说，价值和最大的一定是路径的长度，最小的一定是root（因为root是起点，价值大于0）3.由2得路径越长开销越小，因此最长路径一定遍历到了root。综上可以用树型dp来做，树形dp有个经典应用就是求树的最长路径。但是一般dfs遍历的过程是有方向，对于点a, b,如果按照a -&gt; b的顺序遍历就不会再按照b -&gt; a的顺序遍历了，但是路径的两个端点都有可能成为root最大路径和是一个经典树形 DP 问题，类似「树的直径」。由于我们需要去掉一个叶子，那么可以让子树返回两个值： 带叶子的最大路径和； 不带叶子的最大路径和。 对于当前节点，它有多颗子树，我们一颗颗 DFS，假设当前 DFS 完了其中一颗子树，它返回了「当前带叶子的路径和」和「当前不带叶子的路径和」，那么答案有两种情况： 前面最大带叶子的路径和 + 当前不带叶子的路径和； 前面最大不带叶子的路径和 + 当前带叶子的路径和； 然后更新「最大带叶子的路径和」和「最大不带叶子的路径和」。最后返回「最大带叶子的路径和」和「最大不带叶子的路径和」，用来供父节点计算。 4.3 code:1234567891011121314151617181920212223242526272829303132class Solution {public: using PII = pair&lt;long, long&gt; ; vector&lt;vector&lt;int&gt;&gt; g; vector&lt;int&gt; price; long ans = 0; // 返回带叶子的最大路径和，不带叶子的最大路径和 PII dfs(int x, int fa){ long p = price[x], max_s1 = p, max_s2 = 0; for (int y : g[x]) if (y != fa) { auto[s1, s2] = dfs(y, x); // 前面最大带叶子的路径和 + 当前不带叶子的路径和 // 前面最大不带叶子的路径和 + 当前带叶子的路径和 ans = max(ans, max(max_s1 + s2, max_s2 + s1)); max_s1 = max(max_s1, s1 + p); max_s2 = max(max_s2, s2 + p); } return {max_s1, max_s2}; } long long maxOutput(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges, vector&lt;int&gt; &amp;price) { g.resize(n); this -&gt; price = price; for (auto &amp;e : edges) { int x = e[0], y = e[1]; g[x].push_back(y); g[y].push_back(x); // 建树 } dfs(0, -1); return ans; }}; 4.4 复杂度分析：时间复杂度：o(n) 每个点最多被遍历一次空间复杂度：o(n) 递归深度是n，建图需要的额外空间是2 * n","link":"/2023/01/15/LeetCode328%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/01/15/hello-world/"}],"tags":[{"name":"LC周赛","slug":"LC周赛","link":"/tags/LC%E5%91%A8%E8%B5%9B/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"树形dp","slug":"树形dp","link":"/tags/%E6%A0%91%E5%BD%A2dp/"}],"categories":[],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}